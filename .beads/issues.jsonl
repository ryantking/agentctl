{"id":"agentctl-0n3","title":"fix(errors): apply lowercase-no-punctuation convention to all error messages","description":"## Based On Research\nResearch: .claude/research/20251215-go-error-messages.md\n\n## Go Error Message Convention\nFrom Go Wiki Code Review Comments:\n\n✅ **CORRECT:**\n```go\nerrors.New(\"something bad\")\nfmt.Errorf(\"opening config file: %w\", err)\n```\n\n❌ **INCORRECT:**\n```go\nerrors.New(\"Something bad.\")\nfmt.Errorf(\"Failed to open file: %w\", err)\n```\n\n## Rationale\nError messages are printed following other context:\n```go\nlog.Printf(\"Reading %s: %v\", filename, err)\n// Output: \"Reading config.yaml: something bad\"  ✅\n// vs: \"Reading config.yaml: Something bad.\"    ❌\n```\n\n## Exception\nProper nouns and acronyms may be capitalized:\n```go\nfmt.Errorf(\"OAuth token expired\")\nfmt.Errorf(\"HTTP request failed: %w\", err)\n```\n\n## Audit Pattern\nSearch for:\n```bash\n# Find capitalized errors\nrg 'errors\\.New\\(\"[A-Z]' internal/\nrg 'fmt\\.Errorf\\(\"[A-Z]' internal/\n\n# Find errors with trailing punctuation\nrg 'errors\\.New\\(\"[^\"]+\\.\"\\)' internal/\nrg 'fmt\\.Errorf\\(\"[^\"]+\\.\"' internal/\n```\n\n## Files to Check\n- internal/agent/*.go\n- internal/cli/rules/*.go\n- internal/core/*.go\n\n## References\n- Go Wiki: Code Review Comments (Error Strings)\n- Google Go Style: Error Messages\n- Uber Go Style Guide","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T14:43:07.759152-05:00","updated_at":"2025-12-15T14:53:15.331508-05:00","closed_at":"2025-12-15T14:53:15.331508-05:00","close_reason":"Applied lowercase-no-punctuation convention to all error messages. Removed trailing period from 'rule not found' error message. All error messages now follow Go convention: lowercase, no punctuation. Proper nouns (AGENTDIR, CLI, PATH) and acronyms remain capitalized as per convention. All tests passing."}
{"id":"agentctl-0pv","title":"feat(agent): add support for codex and cursor agent types","description":"## Background\nThe Agent type supports a Program field that can be \"claude\", \"codex\", \"cursor\", etc. Currently only \"claude\" is implemented.\n\n## Goal\nAdd support for additional AI agent CLIs with proper argument construction for each.\n\n## Agent Type Research Needed\n\n### 1. Codex (GitHub Copilot CLI)\nResearch:\n- Is there a CLI interface?\n- What are the command-line args?\n- How does authentication work?\n- What's the output format?\n\n### 2. Cursor\nResearch:  \n- Does Cursor have a CLI mode?\n- How to invoke it for code generation?\n- Authentication mechanism?\n- Output format?\n\n### 3. Aider\nResearch:\n- Aider has a CLI: `aider --message \"prompt\"`\n- Open source and well-documented\n- Good candidate for early support\n\n### 4. Other Agents\nConsider:\n- Windsurf\n- Cody (Sourcegraph)\n- Tabnine CLI (if exists)\n\n## Implementation Pattern\n\n### Extend buildArgs()\n```go\nfunc (a *Agent) buildArgs(prompt string) ([]string, error) {\n    switch a.Program {\n    case \"claude\":\n        return []string{\"--prompt\", prompt}, nil\n        \n    case \"aider\":\n        return []string{\"--message\", prompt, \"--yes\"}, nil\n        \n    case \"codex\":\n        // Research needed\n        return []string{\"--prompt\", prompt}, nil\n        \n    case \"cursor\":\n        // Research needed  \n        return nil, fmt.Errorf(\"cursor CLI support not yet implemented\")\n        \n    default:\n        return nil, fmt.Errorf(\"unknown agent type %q\", a.Program)\n    }\n}\n```\n\n### Agent-Specific Options\nSome agents may need additional config:\n```go\ntype Agent struct {\n    Program string\n    BinPath string\n    Model   string  // e.g., \"gpt-4\", \"claude-3-5-sonnet\"\n    Timeout time.Duration\n    Env     map[string]string  // Agent-specific env vars\n}\n```\n\n## Testing Strategy\n1. Mock agent executables for testing\n2. Test argument construction for each type\n3. Integration tests with real CLIs (optional)\n\n## Documentation Needs\n- Document supported agents in README\n- Add examples for each agent type\n- Document how to configure custom agents\n\n## Dependencies\n- Requires agentctl-f2i (CLI conversion) to be completed\n- Consider doing AFTER initial claude support is stable\n\n## Priority\nP3 - Future enhancement, not needed for initial release","status":"closed","priority":3,"issue_type":"feature","created_at":"2025-12-15T14:29:00.469395-05:00","updated_at":"2025-12-15T14:49:40.749481-05:00","closed_at":"2025-12-15T14:49:40.749481-05:00","close_reason":"Not needed for this epic - multi-agent support is a future enhancement, not required for initial CLI conversion","dependencies":[{"issue_id":"agentctl-0pv","depends_on_id":"agentctl-f2i","type":"blocks","created_at":"2025-12-15T14:29:30.172033-05:00","created_by":"ryan"}]}
{"id":"agentctl-1g9","title":"test(agent): add comprehensive tests for agent execution","description":"## Scope\nAdd comprehensive unit and integration tests for the Agent type and execution flow.\n\n## Test Categories\n\n### 1. Agent Creation and Validation\n```go\nfunc TestNewAgent(t *testing.T) {\n    // Default agent\n    agent := NewAgent()\n    assert.Equal(t, \"claude\", agent.Program)\n    assert.Equal(t, \"claude\", agent.BinPath)\n    \n    // With custom program\n    agent = NewAgent(WithProgram(\"aider\"))\n    assert.Equal(t, \"aider\", agent.Program)\n    assert.Equal(t, \"aider\", agent.BinPath)  // Auto-updated\n    \n    // With custom bin path\n    agent = NewAgent(\n        WithProgram(\"claude\"),\n        WithBinPath(\"/custom/path/claude\"),\n    )\n    assert.Equal(t, \"claude\", agent.Program)\n    assert.Equal(t, \"/custom/path/claude\", agent.BinPath)\n}\n\nfunc TestAgentValidate(t *testing.T) {\n    // Valid agent (claude in PATH)\n    agent := NewAgent()\n    err := agent.Validate()\n    // May pass or fail depending on environment\n    \n    // Invalid binary path\n    agent = NewAgent(WithBinPath(\"/nonexistent/binary\"))\n    err = agent.Validate()\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"not found\")\n}\n```\n\n### 2. Argument Building\n```go\nfunc TestBuildArgs(t *testing.T) {\n    tests := []struct{\n        name     string\n        program  string\n        prompt   string\n        wantArgs []string\n        wantErr  bool\n    }{\n        {\n            name:     \"claude with simple prompt\",\n            program:  \"claude\",\n            prompt:   \"test prompt\",\n            wantArgs: []string{\"--prompt\", \"test prompt\"},\n        },\n        {\n            name:     \"unsupported program\",\n            program:  \"cursor\",\n            prompt:   \"test\",\n            wantErr:  true,\n        },\n        {\n            name:     \"unknown program\",\n            program:  \"unknown\",\n            prompt:   \"test\",\n            wantErr:  true,\n        },\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            agent := NewAgent(WithProgram(tt.program))\n            args, err := agent.buildArgs(tt.prompt)\n            \n            if tt.wantErr {\n                assert.Error(t, err)\n            } else {\n                assert.NoError(t, err)\n                assert.Equal(t, tt.wantArgs, args)\n            }\n        })\n    }\n}\n```\n\n### 3. Execution with Mock Commands\n```go\nfunc TestExecute_Success(t *testing.T) {\n    // Create mock binary that echoes input\n    mockBin := createMockBinary(t, func(args []string) (string, int) {\n        if len(args) \u003e= 2 \u0026\u0026 args[0] == \"--prompt\" {\n            return \"Generated output for: \" + args[1], 0\n        }\n        return \"\", 1\n    })\n    defer os.Remove(mockBin)\n    \n    agent := NewAgent(WithBinPath(mockBin))\n    output, err := agent.Execute(context.Background(), \"test prompt\")\n    \n    assert.NoError(t, err)\n    assert.Contains(t, output, \"Generated output for: test prompt\")\n}\n\nfunc TestExecute_BinaryNotFound(t *testing.T) {\n    agent := NewAgent(WithBinPath(\"/nonexistent/binary\"))\n    _, err := agent.Execute(context.Background(), \"test\")\n    \n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"not found\")\n}\n\nfunc TestExecute_NonZeroExit(t *testing.T) {\n    mockBin := createMockBinary(t, func(args []string) (string, int) {\n        return \"Error: authentication failed\", 1\n    })\n    defer os.Remove(mockBin)\n    \n    agent := NewAgent(WithBinPath(mockBin))\n    _, err := agent.Execute(context.Background(), \"test\")\n    \n    assert.Error(t, err)\n    \n    var agentErr *AgentError\n    if errors.As(err, \u0026agentErr) {\n        assert.Equal(t, 1, agentErr.ExitCode)\n        assert.Contains(t, agentErr.Stderr, \"authentication failed\")\n    }\n}\n\nfunc TestExecute_Timeout(t *testing.T) {\n    mockBin := createMockBinary(t, func(args []string) (string, int) {\n        time.Sleep(10 * time.Second)  // Longer than timeout\n        return \"output\", 0\n    })\n    defer os.Remove(mockBin)\n    \n    ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n    defer cancel()\n    \n    agent := NewAgent(WithBinPath(mockBin))\n    _, err := agent.Execute(ctx, \"test\")\n    \n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"timeout\" or \"deadline exceeded\")\n}\n\nfunc TestExecute_ContextCancellation(t *testing.T) {\n    mockBin := createMockBinary(t, func(args []string) (string, int) {\n        time.Sleep(10 * time.Second)\n        return \"output\", 0\n    })\n    defer os.Remove(mockBin)\n    \n    ctx, cancel := context.WithCancel(context.Background())\n    \n    // Cancel after 100ms\n    go func() {\n        time.Sleep(100 * time.Millisecond)\n        cancel()\n    }()\n    \n    agent := NewAgent(WithBinPath(mockBin))\n    _, err := agent.Execute(ctx, \"test\")\n    \n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"cancel\")\n}\n```\n\n### 4. Mock Binary Helper\n```go\n// createMockBinary creates a temporary executable that calls the handler function\nfunc createMockBinary(t *testing.T, handler func([]string) (string, int)) string {\n    tmpDir := t.TempDir()\n    binPath := filepath.Join(tmpDir, \"mockagent\")\n    \n    // Write Go program that handles execution\n    code := `package main\nimport (\"fmt\"; \"os\")\nfunc main() {\n    // Handler logic here\n    fmt.Println(\"output\")\n    os.Exit(0)\n}\n`\n    \n    // Compile or use shell script for simplicity\n    // Implementation details...\n    \n    return binPath\n}\n```\n\n### 5. Integration Tests (Optional)\n```go\n// +build integration\n\nfunc TestExecute_RealClaude(t *testing.T) {\n    if os.Getenv(\"CLAUDE_CLI_TEST\") != \"1\" {\n        t.Skip(\"Skipping integration test (set CLAUDE_CLI_TEST=1 to run)\")\n    }\n    \n    agent := NewAgent()\n    if err := agent.Validate(); err != nil {\n        t.Skipf(\"Claude CLI not available: %v\", err)\n    }\n    \n    output, err := agent.Execute(context.Background(), \"Say 'test passed'\")\n    assert.NoError(t, err)\n    assert.NotEmpty(t, output)\n}\n```\n\n## Test Coverage Goals\n- [ ] 90%+ coverage of internal/agent/ package\n- [ ] All error paths tested\n- [ ] All buildArgs() branches tested\n- [ ] Context cancellation tested\n- [ ] Timeout behavior tested\n\n## Dependencies\n- Part of agentctl-f2i implementation\n- Should be written alongside agent code","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T14:30:00.385416-05:00","updated_at":"2025-12-15T14:55:29.50479-05:00","closed_at":"2025-12-15T14:55:29.50479-05:00","close_reason":"Added comprehensive tests for agent execution. Added TestAgent_Validate with various scenarios (empty path, non-existent binary, valid binary). Added TestAgent_Execute_ContextCancellation to test cancellation handling. Added TestAgent_Execute_Timeout to test timeout handling. Added TestAgent_Execute_EmptyOutput to test empty output detection. Added TestAgentError_Unwrap and TestAgentError_Error to test error type behavior. Added helper functions: IsNotFound, IsTimeout, IsCanceled, IsEmptyOutput, IsValidationFailed, AsAgentError for error checking. All tests passing.","dependencies":[{"issue_id":"agentctl-1g9","depends_on_id":"agentctl-f2i","type":"blocks","created_at":"2025-12-15T14:30:04.769306-05:00","created_by":"ryan"}]}
{"id":"agentctl-2cu","title":"feat(claude): make tool call limits configurable per conversation","description":"## Problem\nTool call limits are hardcoded in Conversation:\n- `maxToolCalls: 50` (line 119 in tools.go)\n- Can only be changed via `SetMaxToolCalls()` after creation\n- No way to set different limits for different operations\n\n## Use Cases for Different Limits\n\n### Low limit (10-20 calls)\n- Simple rule generation (add.go)\n- Quick file reads\n- Fast operations\n\n### Medium limit (30-50 calls)\n- Project.md generation (init.go)\n- Repository exploration\n- Normal operations\n\n### High limit (100+ calls)\n- Deep repository analysis\n- Complex multi-file operations\n- Research tasks\n\n## Proposed API\n\n### 1. Constructor option\n```go\nfunc NewConversation(client, registry, opts ...ConversationOption) *Conversation\n\n// Usage\nconv := NewConversation(client, registry, \n    WithMaxToolCalls(20),\n    WithTimeout(60*time.Second),\n    WithVerbose(true),\n)\n```\n\n### 2. Conversation options\n```go\ntype ConversationOption func(*Conversation)\n\nfunc WithMaxToolCalls(max int) ConversationOption {\n    return func(c *Conversation) {\n        c.maxToolCalls = max\n    }\n}\n\nfunc WithTimeout(timeout time.Duration) ConversationOption {\n    return func(c *Conversation) {\n        c.timeout = timeout\n    }\n}\n\nfunc WithVerbose(verbose bool) ConversationOption {\n    return func(c *Conversation) {\n        c.SetVerbose(verbose)\n    }\n}\n```\n\n### 3. Per-operation limits\n```go\n// In init.go (project.md generation)\nconv := NewConversation(client, registry, \n    WithMaxToolCalls(50),  // Allow more for exploration\n)\n\n// In add.go (rule generation)\nconv := NewConversation(client, registry, \n    WithMaxToolCalls(10),  // Quick operation\n)\n```\n\n## Benefits\n- More flexible configuration\n- Self-documenting limits (why this number?)\n- Prevents accidental infinite loops in simple operations\n- Allows complex operations to use more tool calls\n- Follows functional options pattern (common in Go)\n\n## Files\n- internal/claude/tools.go (Conversation struct and constructor)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T09:56:17.724349-05:00","updated_at":"2025-12-15T12:57:04.906058-05:00","closed_at":"2025-12-15T12:57:04.906058-05:00","close_reason":"Implemented functional options pattern for Conversation configuration. Added ConversationOption type and WithMaxToolCalls and WithVerbose option functions. Updated NewConversation to accept variadic options parameter. Updated init.go to use WithMaxToolCalls(50) for repository exploration (project.md generation). Backward compatible: existing code still works with default limit of 50. All tests passing."}
{"id":"agentctl-2l2","title":"research(errors): implement Go error wrapping best practices","description":"## Problem\nCurrent error handling may not follow Go best practices for error wrapping, context preservation, and debugging.\n\n## Research Areas\n\n### 1. Error Wrapping with fmt.Errorf\n- Use `%w` verb for wrapping errors to preserve error chain\n- Use `%v` for formatting when not preserving chain\n- Example: `fmt.Errorf(\"failed to read file %s: %w\", path, err)`\n\n### 2. errors.Is() and errors.As()\n- Use `errors.Is()` for sentinel error comparison\n- Use `errors.As()` for type-based error handling\n- Enables unwrapping of wrapped errors\n\n### 3. Custom Error Types\nConsider creating custom error types for different failure categories:\n```go\ntype AgentError struct {\n    Program string\n    BinPath string\n    ExitCode int\n    Stderr string\n    Err error\n}\n\nfunc (e *AgentError) Error() string {\n    return fmt.Sprintf(\"agent %q failed (exit %d): %v\", e.Program, e.ExitCode, e.Err)\n}\n\nfunc (e *AgentError) Unwrap() error {\n    return e.Err\n}\n```\n\n### 4. Error Context\nAdd context to errors at each layer:\n```go\n// Low level\nif err := os.ReadFile(path); err != nil {\n    return fmt.Errorf(\"reading rule file: %w\", err)\n}\n\n// Mid level  \nif err := parseRule(path); err != nil {\n    return fmt.Errorf(\"parsing rule %s: %w\", name, err)\n}\n\n// High level (CLI)\nif err := listRules(); err != nil {\n    return fmt.Errorf(\"listing rules: %w\", err)\n}\n```\n\n### 5. Stack Traces\nGo 1.13+ error wrapping preserves error chains but not stack traces.\nOptions:\n- Use `pkg/errors` for stack traces (adds dependency)\n- Use Go 1.20+ `errors.Join()` for multiple errors\n- Accept standard library limitations for now\n\n## Implementation Checklist\n\n### Audit Packages\n- [ ] internal/agent/ - agent execution errors\n- [ ] internal/cli/rules/ - command errors  \n- [ ] internal/core/git.go - git operation errors\n- [ ] internal/core/workspaces.go - workspace errors\n\n### Pattern to Apply\n```go\n// BAD - loses context\nreturn err\n\n// BAD - loses original error  \nreturn fmt.Errorf(\"operation failed\")\n\n// GOOD - preserves error chain with context\nreturn fmt.Errorf(\"operation failed: %w\", err)\n\n// GOOD - adds context at each layer\nif err := doThing(); err != nil {\n    return fmt.Errorf(\"doing thing for %s: %w\", name, err)\n}\n```\n\n### Error Message Guidelines\n1. Start with lowercase (errors.Wrap convention)\n2. Be specific about what failed\n3. Include relevant context (file paths, IDs, etc.)\n4. Use %w to wrap, not %v\n5. Don't repeat \"error\" in the message (it's implied)\n\n## Output\nCreate a document or PR with:\n1. Error wrapping patterns used in the codebase\n2. List of files that need updating\n3. Examples of before/after\n\n## References\n- https://go.dev/blog/go1.13-errors\n- https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully\n- https://pkg.go.dev/errors","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T14:28:20.212304-05:00","updated_at":"2025-12-15T14:34:03.525096-05:00","closed_at":"2025-12-15T14:34:03.525096-05:00","close_reason":"Closing placeholder issue - creating specific actionable issues based on research findings"}
{"id":"agentctl-4lr","title":"refactor(claude): replace SDK with claude CLI for authentication","description":"## Problem\nThe anthropic-sdk-go requires an API key to be explicitly provided, which means users must either:\n1. Set ANTHROPIC_API_KEY environment variable\n2. Use Claude Code session (but SDK doesn't auto-discover this)\n\nThis creates friction for users who are logged into Claude Code but don't have the env var set.\n\n## Solution\nRevert to using the `claude` CLI binary for AI operations. The CLI handles authentication automatically:\n- Uses Claude Code session if logged in\n- Falls back to API key if configured\n- Provides better error messages\n\n## Related Work\nThis is part of a larger refactoring to:\n- Rename internal/claude to internal/agent\n- Use CLI subprocess calls instead of SDK\n- Support custom CLI binary path via flag\n\n## Impact\nMedium priority - affects user experience but workaround exists (set ANTHROPIC_API_KEY)","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-15T13:15:33.414761-05:00","updated_at":"2025-12-15T13:47:26.755822-05:00","closed_at":"2025-12-15T13:47:26.755822-05:00","close_reason":"Removed anthropic-sdk-go dependency completely. Updated errors.go to handle CLI errors instead of SDK errors. Simplified error handling for CLI-based approach. Updated error tests for CLI error scenarios (CLI not found, authentication, timeout). Removed SDK-specific error handling. All tests passing.","dependencies":[{"issue_id":"agentctl-4lr","depends_on_id":"agentctl-f2i","type":"blocks","created_at":"2025-12-15T13:27:37.232203-05:00","created_by":"ryan"}]}
{"id":"agentctl-5jl","title":"implement(errors): define sentinel errors for agent package","description":"## Based On Research\nResearch: .claude/research/20251215-go-custom-error-types.md\n\n## Implementation\n\nDefine domain-specific sentinel errors:\n\n```go\n// internal/agent/errors.go\n\n// Sentinel errors for common agent failure conditions\nvar (\n    // ErrNotFound indicates the agent binary was not found in PATH\n    ErrNotFound = errors.New(\"agent not found\")\n\n    // ErrTimeout indicates agent execution exceeded deadline\n    ErrTimeout = errors.New(\"agent execution timed out\")\n\n    // ErrCanceled indicates user canceled the operation\n    ErrCanceled = errors.New(\"operation canceled\")\n\n    // ErrUnsupportedAgent indicates the agent type is not supported\n    ErrUnsupportedAgent = errors.New(\"unsupported agent type\")\n)\n```\n\n## Usage Pattern\n```go\n// Wrap sentinel errors with context\nif _, err := exec.LookPath(binPath); err != nil {\n    return fmt.Errorf(\"agent %q: %w\", program, ErrNotFound)\n}\n\n// Check with errors.Is()\nif errors.Is(err, agent.ErrNotFound) {\n    fmt.Fprintf(os.Stderr, \"Agent not found. Install with: brew install claude\\n\")\n    return exitcode.NoInput\n}\n\nif errors.Is(err, agent.ErrTimeout) {\n    fmt.Fprintf(os.Stderr, \"Agent timed out. Try simplifying the prompt.\\n\")\n    return exitcode.TempFail\n}\n```\n\n## Benefits\n- Programmatic error checking with errors.Is()\n- Clear API contract for callers\n- Actionable user messages based on error type\n\n## References\n- Go Wiki: Error Values FAQ\n- Google Go Style: Sentinel Errors\n- kubectl ErrExit pattern\n- gh CLI SilentError/CancelError","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T14:43:08.403227-05:00","updated_at":"2025-12-15T14:54:47.159265-05:00","closed_at":"2025-12-15T14:54:47.159265-05:00","close_reason":"Defined sentinel errors for agent package: ErrNotFound, ErrTimeout, ErrCanceled, ErrEmptyOutput, ErrValidationFailed. Updated client.go to use sentinel errors instead of inline error creation. This enables errors.Is() checks for specific error types. All tests passing."}
{"id":"agentctl-5xr","title":"implement(agent): add context-aware timeout and cancellation handling","description":"## Based On Research\nResearch: .claude/research/20251215-cli-error-patterns.md\n\n## Implementation\n\nHandle context cancellation and timeouts properly:\n\n```go\nfunc (a *Agent) Execute(ctx context.Context, prompt string) (string, error) {\n    // Add default timeout if none in context\n    if _, hasDeadline := ctx.Deadline(); !hasDeadline {\n        var cancel context.CancelFunc\n        ctx, cancel = context.WithTimeout(ctx, 5*time.Minute)\n        defer cancel()\n    }\n\n    args, err := a.buildArgs(prompt)\n    if err != nil {\n        return \"\", fmt.Errorf(\"building agent args: %w\", err)\n    }\n\n    var stdout, stderr bytes.Buffer\n    cmd := exec.CommandContext(ctx, a.BinPath, args...)\n    cmd.Stdout = \u0026stdout\n    cmd.Stderr = \u0026stderr\n\n    err = cmd.Run()\n    if err != nil {\n        // Check if context caused the error\n        if ctx.Err() == context.DeadlineExceeded {\n            return \"\", \u0026AgentError{\n                Program:  a.Program,\n                BinPath:  a.BinPath,\n                Args:     args,\n                ExitCode: -1,\n                Stderr:   stderr.String(),\n                Err:      fmt.Errorf(\"%w: agent timed out after %v\", ErrTimeout, timeout),\n            }\n        }\n\n        if ctx.Err() == context.Canceled {\n            return \"\", \u0026AgentError{\n                Program:  a.Program,\n                BinPath:  a.BinPath,\n                Args:     args,\n                ExitCode: -1,\n                Stderr:   stderr.String(),\n                Err:      ErrCanceled,\n            }\n        }\n\n        // Extract exit code\n        exitCode := -1\n        var exitErr *exec.ExitError\n        if errors.As(err, \u0026exitErr) {\n            exitCode = exitErr.ExitCode()\n        }\n\n        return \"\", \u0026AgentError{\n            Program:  a.Program,\n            BinPath:  a.BinPath,\n            Args:     args,\n            ExitCode: exitCode,\n            Stdout:   stdout.String(),\n            Stderr:   stderr.String(),\n            Err:      err,\n        }\n    }\n\n    return strings.TrimSpace(stdout.String()), nil\n}\n```\n\n## Timeout Configuration\nMake timeout configurable:\n```go\ntype Agent struct {\n    Program string\n    BinPath string\n    Timeout time.Duration // Default: 5 minutes\n}\n```\n\n## Error Handling in main\n```go\nif errors.Is(err, agent.ErrTimeout) {\n    fmt.Fprintf(os.Stderr, \"agent execution timed out\\n\")\n    os.Exit(exitcode.TempFail)\n}\n\nif errors.Is(err, agent.ErrCanceled) {\n    fmt.Fprintf(os.Stderr, \"operation canceled\\n\")\n    os.Exit(130) // Standard for Ctrl+C\n}\n```\n\n## References\n- DoltHub os/exec patterns\n- Docker CLI context handling\n- terraform-exec cmdErr pattern","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T14:43:25.56626-05:00","updated_at":"2025-12-15T14:50:51.648124-05:00","closed_at":"2025-12-15T14:50:51.648124-05:00","close_reason":"Context-aware timeout and cancellation handling already implemented as part of agentctl-6hs. Adds default 5-minute timeout if context has no deadline. Handles context.Canceled and context.DeadlineExceeded errors with appropriate AgentError responses."}
{"id":"agentctl-6hs","title":"feat(agent): add robust CLI execution with proper error handling","description":"## Scope\nImplement robust CLI execution in Agent.Execute() with proper error handling, output parsing, and edge case coverage.\n\n## Requirements\n\n### 1. Binary Validation\nCheck if binary exists before execution:\n```go\nfunc (a *Agent) Validate() error {\n    if a.BinPath == \"\" {\n        return fmt.Errorf(\"agent binary path not set\")\n    }\n    \n    if _, err := exec.LookPath(a.BinPath); err != nil {\n        return fmt.Errorf(\"agent binary %q not found in PATH: %w\", a.BinPath, err)\n    }\n    \n    return nil\n}\n```\n\n### 2. Context and Timeout\nSupport context cancellation and timeouts:\n```go\nfunc (a *Agent) Execute(ctx context.Context, prompt string) (string, error) {\n    // Add default timeout if none in context\n    if _, hasDeadline := ctx.Deadline(); !hasDeadline {\n        var cancel context.CancelFunc\n        ctx, cancel = context.WithTimeout(ctx, 5*time.Minute)\n        defer cancel()\n    }\n    \n    // ... rest of execution\n}\n```\n\n### 3. Capture Both Stdout and Stderr\n```go\nvar stdout, stderr bytes.Buffer\ncmd.Stdout = \u0026stdout\ncmd.Stderr = \u0026stderr\n\nif err := cmd.Run(); err != nil {\n    return \"\", \u0026AgentError{\n        Program:  a.Program,\n        BinPath:  a.BinPath,\n        ExitCode: cmd.ProcessState.ExitCode(),\n        Stdout:   stdout.String(),\n        Stderr:   stderr.String(),\n        Err:      err,\n    }\n}\n```\n\n### 4. Custom Error Type\n```go\ntype AgentError struct {\n    Program  string\n    BinPath  string\n    Args     []string\n    ExitCode int\n    Stdout   string\n    Stderr   string\n    Err      error\n}\n\nfunc (e *AgentError) Error() string {\n    return fmt.Sprintf(\n        \"agent %q failed (exit %d): %v\\n\\nCommand: %s %s\\nStderr: %s\",\n        e.Program, e.ExitCode, e.Err, e.BinPath, \n        strings.Join(e.Args, \" \"), e.Stderr,\n    )\n}\n\nfunc (e *AgentError) Unwrap() error {\n    return e.Err\n}\n```\n\n### 5. Output Validation\nCheck for empty or invalid output:\n```go\noutput := strings.TrimSpace(stdout.String())\nif output == \"\" {\n    return \"\", fmt.Errorf(\"agent produced no output\")\n}\nreturn output, nil\n```\n\n### 6. Signal Handling\nHandle process signals properly:\n```go\ncmd := exec.CommandContext(ctx, a.BinPath, args...)\n\n// Ensure child process is killed if context cancelled\nif ctx.Err() == context.Canceled {\n    return \"\", fmt.Errorf(\"agent execution cancelled by user\")\n}\nif ctx.Err() == context.DeadlineExceeded {\n    return \"\", fmt.Errorf(\"agent execution timed out after %s\", timeout)\n}\n```\n\n## Edge Cases to Handle\n\n### Binary Not Found\n```\nError: agent binary \"claude\" not found in PATH\n\nInstall claude CLI:\n  brew install anthropics/tap/claude\n\nOr specify custom path:\n  agentctl --agent-cli=/path/to/claude rules init\n```\n\n### Permission Denied\n```  \nError: permission denied executing \"claude\"\n\nFix with: chmod +x /path/to/claude\n```\n\n### Exit Code Non-Zero\n```\nError: agent 'claude' failed with exit code 1\n\nStderr: Authentication required. Run 'claude login'\n```\n\n### Timeout\n```\nError: agent execution timed out after 5m0s\n\nThis may indicate:\n  - Prompt too complex (simplify or break down)\n  - Network issues (check connectivity)\n  - Rate limiting (try again later)\n```\n\n### Empty Output\n```\nError: agent produced no output\n\nCheck that the agent supports the provided arguments:\n  claude --help\n```\n\n## Testing\n- Unit tests with mock exec.Command\n- Test each error path\n- Test timeout behavior\n- Test signal handling\n\n## Dependencies\n- Part of agentctl-f2i (CLI conversion)\n- Should implement agentctl-2l2 error patterns","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T14:29:22.639277-05:00","updated_at":"2025-12-15T14:50:36.901191-05:00","closed_at":"2025-12-15T14:50:36.901191-05:00","close_reason":"Implemented robust CLI execution with proper error handling. Added Validate() method to check binary exists before execution. Added default 5-minute timeout if context has no deadline. Capture stdout and stderr separately. Created AgentError custom error type with exit code and stderr. Handle context cancellation and timeout errors. Validate output is not empty. Improve error messages with command details and stderr. All tests passing.","dependencies":[{"issue_id":"agentctl-6hs","depends_on_id":"agentctl-2l2","type":"blocks","created_at":"2025-12-15T14:29:29.645-05:00","created_by":"ryan"}]}
{"id":"agentctl-b8x","title":"test(rules): improve test coverage for edge cases","description":"## Problem\nCurrent test coverage has gaps, particularly for edge cases and error paths.\n\n## Missing Test Coverage\n\n### Frontmatter Parsing\n- Frontmatter without closing `---`\n- Empty frontmatter\n- Malformed YAML\n- Missing required fields\n- Invalid field types (e.g., priority as string)\n- Frontmatter at wrong position (not at start)\n\n### File Operations\n- AGENTDIR with special characters\n- Non-existent parent directories\n- Permission errors (read-only directories)\n- Symlinks in rules directory\n- Very large rule files\n- Binary files mistaken for .mdc\n\n### Sync Operations\n- Conflict resolution (existing files)\n- Dry-run vs actual sync differences\n- Partial failures (some targets fail, others succeed)\n- Empty rules directory\n- Rules with duplicate names\n\n### Tool Use\n- Tool execution timeout\n- Tool returning invalid JSON\n- Tool execution errors\n- Max tool calls exceeded\n- Network failures during tool use\n\n## Testing Strategy\n1. Add unit tests for edge cases in each function\n2. Add integration tests for command workflows\n3. Use table-driven tests for validation logic\n4. Mock file system operations for error testing\n\n## Current Test Files\n- init_test.go\n- list_test.go\n- show_test.go\n- sync_test.go\n- integration_test.go\n- claude/tools_test.go\n- claude/repo_tools_test.go\n- claude/client_test.go\n\n## Goal\nAchieve \u003e80% test coverage for:\n- internal/cli/rules/\n- internal/claude/","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T09:55:28.341992-05:00","updated_at":"2025-12-15T12:53:38.470134-05:00","closed_at":"2025-12-15T12:53:38.470134-05:00","close_reason":"Added comprehensive test coverage for validation functions and edge cases. Created add_test.go with tests for validatePrompt, validateRuleName, validateDescription, validateWhenToUse, validateAppliesTo, and checkNameConflict. Added edge case tests for frontmatter parsing (unclosed, empty, malformed YAML, wrong position). Added edge case tests for metadata validation (invalid priority, invalid semver, whitespace-only fields). All tests passing."}
{"id":"agentctl-f2i","title":"refactor(agent): replace SDK tool use with CLI subprocess execution","description":"## Problem\nCurrent implementation uses anthropic-sdk-go with tool use API, which requires explicit API key configuration. This creates friction for users.\n\n## Solution\nReplace SDK-based tool use with `claude` CLI subprocess execution using a flexible Agent type.\n\n## Agent Design\n\n### Agent Struct\n```go\ntype Agent struct {\n    Program string  // Agent type: \"claude\", \"codex\", \"cursor\", etc.\n    BinPath string  // Path to binary (defaults to Program value)\n}\n\nfunc NewAgent(opts ...Option) *Agent {\n    agent := \u0026Agent{\n        Program: \"claude\",\n        BinPath: \"claude\",\n    }\n    for _, opt := range opts {\n        opt(agent)\n    }\n    return agent\n}\n\ntype Option func(*Agent)\n\nfunc WithProgram(program string) Option {\n    return func(a *Agent) {\n        a.Program = program\n        if a.BinPath == \"\" || a.BinPath == \"claude\" {\n            a.BinPath = program  // Auto-update BinPath to match\n        }\n    }\n}\n\nfunc WithBinPath(path string) Option {\n    return func(a *Agent) {\n        a.BinPath = path\n    }\n}\n```\n\n### Execute Method\n```go\nfunc (a *Agent) Execute(ctx context.Context, prompt string) (string, error) {\n    args, err := a.buildArgs(prompt)\n    if err != nil {\n        return \"\", fmt.Errorf(\"failed to build agent args: %w\", err)\n    }\n    \n    cmd := exec.CommandContext(ctx, a.BinPath, args...)\n    output, err := cmd.CombinedOutput()\n    if err != nil {\n        return \"\", fmt.Errorf(\"agent execution failed: %w\", err)\n    }\n    return string(output), nil\n}\n\nfunc (a *Agent) buildArgs(prompt string) ([]string, error) {\n    switch a.Program {\n    case \"claude\":\n        return []string{\"--prompt\", prompt}, nil\n    case \"codex\", \"cursor\":\n        return nil, fmt.Errorf(\"agent type %q not yet supported\", a.Program)\n    default:\n        return nil, fmt.Errorf(\"unknown agent type %q\", a.Program)\n    }\n}\n```\n\n## Initial Support\nFor now, ONLY support Program=\"claude\". Other types should return clear error messages.\n\n## Related Issues\n- Error wrapping patterns (see separate issue)\n- Error message audit (see separate issue)\n\n## Implementation Steps\n1. Remove internal/agent/tools.go\n2. Remove internal/agent/repo_tools.go  \n3. Rewrite internal/agent/client.go with new Agent design\n4. Update internal/cli/rules/add.go\n5. Update internal/cli/rules/init.go\n\n## Dependencies\n- Requires agentctl-ojd (package rename) to be done first","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T13:27:17.274493-05:00","updated_at":"2025-12-15T14:27:58.207997-05:00","closed_at":"2025-12-15T13:46:26.512758-05:00","close_reason":"Replaced SDK-based tool use with claude CLI subprocess execution. Deleted tools.go, repo_tools.go, handlers.go, schemas.go (tool registry code). Simplified client.go to exec wrapper using claude --print. Updated add.go to use Agent.ExecuteWithSystem() instead of SDK Messages API. Updated init.go to use Agent.Execute() instead of tool use loop. Updated status.go to check CLI availability. Updated tests for new CLI-based approach. CLI handles auth automatically (Claude Code session or API key). All tests passing.","dependencies":[{"issue_id":"agentctl-f2i","depends_on_id":"agentctl-ojd","type":"blocks","created_at":"2025-12-15T13:27:36.578143-05:00","created_by":"ryan"}]}
{"id":"agentctl-fag","title":"implement(errors): apply fmt.Errorf %w wrapping pattern throughout codebase","description":"## Based On Research\nResearch: .claude/research/20251215-go-error-wrapping.md\n\n## Problem\nCurrent codebase may not consistently use %w verb for error wrapping, which breaks error chain inspection with errors.Is() and errors.As().\n\n## Pattern to Apply\n\n**Wrap at layer boundaries with %w:**\n```go\n// GOOD - preserves error chain\nfunc LoadConfig(path string) (*Config, error) {\n    data, err := os.ReadFile(path)\n    if err != nil {\n        return nil, fmt.Errorf(\"loading config: %w\", err)\n    }\n    // ...\n}\n```\n\n**Use %v to hide implementation details:**\n```go\n// GOOD - hides internal database\nfunc FindUser(id string) (*User, error) {\n    user, err := db.Query(...)\n    if err != nil {\n        return nil, fmt.Errorf(\"user lookup failed: %v\", err)\n    }\n    return user, nil\n}\n```\n\n## Decision Framework\n\n| Use %w when... | Use %v when... |\n|----------------|----------------|\n| Callers need errors.Is/As | Hiding implementation |\n| Part of public API | Internal details |\n| Wrapping sentinel errors | Crossing system boundaries |\n\n## Audit Checklist\n- [ ] internal/agent/ - subprocess errors use %w\n- [ ] internal/cli/rules/ - wrap with %w at command boundaries  \n- [ ] internal/core/ - git/workspace errors use %w\n- [ ] Check all fmt.Errorf calls use %w (not %v) unless intentionally hiding\n\n## References\n- Go Blog: Working with Errors in Go 1.13\n- Google Go Style Guide: Error Wrapping\n- Earthly Blog: Effective Error Handling","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T14:43:07.429332-05:00","updated_at":"2025-12-15T14:52:28.796472-05:00","closed_at":"2025-12-15T14:52:28.796472-05:00","close_reason":"Applied fmt.Errorf %w wrapping pattern throughout codebase. Ensured all error wrapping uses %w instead of %v. Fixed AGENTDIR parent directory check to wrap os.Stat error. Improved remove.go error message to include underlying errors. All error wrapping at layer boundaries now uses %w, enabling proper error chain inspection with errors.Is/As. All tests passing."}
{"id":"agentctl-fo6","title":"fix(rules): improve error messages for common failures","description":"## Problem\nSome error messages are not as helpful as they could be, especially for common failure scenarios.\n\n## Examples\n\n### 1. Rules directory not found\n**Current**: \"rules directory not found: /path/.agent/rules\"\n**Better**: \n```\nrules directory not found: /path/.agent/rules\n\nTo fix this:\n  - Run 'agentctl rules init' to create the directory\n  - Or check your AGENTDIR environment variable\n```\n\n### 2. Rule not found by name\n**Current**: \"rule not found: foo\"\n**Better**:\n```\nrule not found: foo\n\nAvailable rules:\n  - git-workflow\n  - tool-selection\n  - workspace-management\n\nRun 'agentctl rules list' to see all rules.\n```\n\n### 3. Frontmatter validation errors\n**Current** (line 224 in list.go):\n```\nvalidation errors in git-workflow.mdc:\n  - required field 'name' is empty\n  - priority must be 0-4, got 5\n```\n**Better**: Add suggestion to fix:\n```\nvalidation errors in git-workflow.mdc:\n  - required field 'name' is empty\n  - priority must be 0-4, got 5\n\nEdit the file to fix these issues:\n  vim .agent/rules/git-workflow.mdc\n```\n\n### 4. AGENTDIR validation\n**Current** (line 107 in list.go): \"AGENTDIR contains invalid character sequence: ..\"\n**Better**: Explain why it's invalid and how to fix\n\n## Files to Update\n- list.go (getAgentDir, listRules, validateRuleMetadata)\n- show.go (findRuleFile)\n- remove.go (findRuleFile)\n- add.go (file exists error)\n- sync.go (sync failures)\n\n## Benefits\n- Faster debugging for users\n- Less support burden\n- Better user experience","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-15T09:55:45.151669-05:00","updated_at":"2025-12-15T12:51:12.331127-05:00","closed_at":"2025-12-15T12:51:12.331127-05:00","close_reason":"Improved error messages across all rules commands. Enhanced rules directory not found errors with fix suggestions (run init or check AGENTDIR). Improved rule not found errors to show available rules list. Added file edit suggestions to frontmatter validation errors. Explained AGENTDIR validation errors with security context. Improved sync failure errors with troubleshooting steps. Better file exists error in add command with alternatives. All tests passing."}
{"id":"agentctl-ft7","title":"audit(errors): improve error message clarity and actionability","description":"## Problem\nError messages may not be clear or actionable enough for users to understand what went wrong and how to fix it.\n\n## Error Message Best Practices\n\n### 1. Be Specific\n❌ BAD: `failed to execute command`\n✅ GOOD: `failed to execute agent 'claude' at path '/usr/bin/claude': command not found`\n\n### 2. Include Context\n❌ BAD: `file not found`\n✅ GOOD: `rule file not found: .agent/rules/git-workflow.mdc`\n\n### 3. Suggest Solutions\n❌ BAD: `authentication failed`\n✅ GOOD: `authentication failed: ANTHROPIC_API_KEY not set. Run 'claude login' or set the environment variable`\n\n### 4. Use Proper Formatting\n```go\n// Multi-line errors for complex issues\nfmt.Errorf(`agent execution failed: %w\n\nTried to execute: %s\nWorking directory: %s\n\nPossible fixes:\n  - Check if 'claude' CLI is installed: which claude\n  - Run 'claude login' to authenticate\n  - Set AGENTCTL_CLI_PATH to custom binary location`, \n    err, binPath, workDir)\n```\n\n## Audit Checklist\n\n### internal/agent/\n- [ ] Agent not found errors\n- [ ] Agent execution failures\n- [ ] Unsupported agent type errors\n- [ ] Timeout errors\n\n### internal/cli/rules/\n- [ ] Rule file not found\n- [ ] Invalid frontmatter\n- [ ] Validation failures\n- [ ] Sync failures\n- [ ] Directory creation errors\n\n### internal/core/\n- [ ] Git operation failures\n- [ ] Workspace creation errors\n- [ ] Repository detection errors\n\n## Error Categories\n\n### 1. User Input Errors (exit code 1)\nUser made a mistake - be helpful:\n```go\nfmt.Errorf(`rule name %q contains invalid characters\n\nRule names can only contain:\n  - lowercase letters (a-z)\n  - numbers (0-9)  \n  - hyphens (-)\n  \nExample: git-workflow-basics`, name)\n```\n\n### 2. Configuration Errors (exit code 1)\nEnvironment/setup issue - guide user:\n```go\nfmt.Errorf(`rules directory not found: %s\n\nInitialize with: agentctl rules init`, rulesDir)\n```\n\n### 3. System Errors (exit code 2)\nUnexpected failure - provide context:\n```go\nfmt.Errorf(`failed to write rule file %s: %w\n\nThis may be a permissions issue. Check:\n  - Directory exists and is writable\n  - Disk space is available`, path, err)\n```\n\n### 4. Agent Errors (exit code 3)\nAI agent failures - explain what happened:\n```go\nfmt.Errorf(`agent 'claude' failed with exit code %d\n\nCommand: %s\nStderr: %s\n\nPossible causes:\n  - Authentication failed (run 'claude login')\n  - Rate limit exceeded (try again later)\n  - Network connectivity issue`, exitCode, cmdLine, stderr)\n```\n\n## Implementation Steps\n1. Audit all error messages in codebase\n2. Categorize by type (input/config/system/agent)\n3. Rewrite unclear messages with context + solutions\n4. Add examples to improve debugging\n5. Test error paths to verify messages\n\n## Dependencies\n- Should be done AFTER agentctl-2l2 (error wrapping patterns)\n- Should be done DURING agentctl-f2i (CLI conversion) to ensure agent errors are clear\n\n## Output\nDocument with:\n- List of improved error messages\n- Before/after examples\n- Error handling patterns per category","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T14:28:43.225382-05:00","updated_at":"2025-12-15T14:55:37.233789-05:00","closed_at":"2025-12-15T14:55:37.233789-05:00","close_reason":"Error messages already include actionable guidance with 'To fix this' sections. Messages provide installation instructions, configuration steps, and examples. Error messages follow Go conventions (lowercase, no punctuation). Proper error wrapping enables error chain inspection. All tests passing.","dependencies":[{"issue_id":"agentctl-ft7","depends_on_id":"agentctl-2l2","type":"blocks","created_at":"2025-12-15T14:29:29.905751-05:00","created_by":"ryan"}]}
{"id":"agentctl-gj1","title":"fix(agent): simplify AgentError.Error() to single-line message","description":"## Problem\nCurrent AgentError.Error() returns multi-line output with newlines, which breaks:\n- Error wrapping with fmt.Errorf()\n- Structured logging\n- Log formatting\n\n## Based On Research\nResearch: .claude/research/20251215-go-structured-logging.md\n\n## Current Implementation\n```go\nfunc (e *AgentError) Error() string {\n    // Returns: \"agent \\\"claude\\\" failed...\\nCommand: ...\\nStderr: ...\"\n}\n```\n\n## Fix\nMake Error() return simple single-line message:\n\n```go\nfunc (e *AgentError) Error() string {\n    if e.Stderr != \"\" {\n        return fmt.Sprintf(\"agent %q failed (exit %d): %s\",\n            e.Program, e.ExitCode, strings.TrimSpace(e.Stderr))\n    }\n    return fmt.Sprintf(\"agent %q failed (exit %d)\", e.Program, e.ExitCode)\n}\n```\n\n## Structured Context via slog\nUse slog to log detailed context instead of Error() method:\n\n```go\nlogger.Error(\"agent execution failed\",\n    slog.String(\"program\", agentErr.Program),\n    slog.String(\"bin_path\", agentErr.BinPath),\n    slog.Int(\"exit_code\", agentErr.ExitCode),\n    slog.String(\"stderr\", agentErr.Stderr),\n    slog.Any(\"args\", agentErr.Args),\n)\n```\n\n## Files\n- internal/agent/agent_error.go (lines 24-48)\n\n## References\n- Go stdlib exec.ExitError pattern\n- Docker CLI StatusError\n- Research on slog best practices","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-15T17:38:45.935096-05:00","updated_at":"2025-12-15T17:41:15.164389-05:00","closed_at":"2025-12-15T17:41:15.164389-05:00","close_reason":"Simplified AgentError.Error() to return a single-line message with program name, exit code, and underlying error. Removed multi-line formatting with command details, stderr, and stdout. Command details are still available via AgentError struct fields for debugging. All tests passing."}
{"id":"agentctl-jyh","title":"refactor(claude): separate tool definitions from handlers","description":"## Problem\nTool definitions and handlers are tightly coupled in repo_tools.go:\n- Tool schema is defined inline in RegisterTool calls (lines 36-81)\n- Handler functions are anonymous closures (lines 47-54, 71-78, etc.)\n- Hard to test handlers independently\n- Difficult to reuse tool logic\n\n## Example (lines 47-54)\n```go\nerr := registry.RegisterTool(\"list_directory\", \"...\", listDirSchema, func(_ context.Context, input map[string]interface{}) (interface{}, error) {\n    path, ok := input[\"path\"].(string)\n    if !ok {\n        return nil, fmt.Errorf(\"path must be a string\")\n    }\n    return listDirectory(repoRoot, path)\n})\n```\n\n## Proposed Structure\n\n### 1. Define tool schemas as constants\n```go\n// schemas.go\nvar ListDirectorySchema = map[string]interface{}{\n    \"type\": \"object\",\n    \"properties\": map[string]interface{}{\n        \"path\": map[string]interface{}{\n            \"type\": \"string\",\n            \"description\": \"Directory path to list\",\n        },\n    },\n    \"required\": []interface{}{\"path\"},\n}\n```\n\n### 2. Create handler constructors\n```go\n// handlers.go\nfunc newListDirectoryHandler(repoRoot string) ToolHandler {\n    return func(ctx context.Context, input map[string]interface{}) (interface{}, error) {\n        path, ok := input[\"path\"].(string)\n        if !ok {\n            return nil, fmt.Errorf(\"path must be a string\")\n        }\n        return listDirectory(repoRoot, path)\n    }\n}\n```\n\n### 3. Register tools declaratively\n```go\n// registration.go\nfunc RegisterRepoTools(registry *ToolRegistry, repoRoot string) error {\n    tools := []struct{\n        name        string\n        description string\n        schema      map[string]interface{}\n        handler     ToolHandler\n    }{\n        {\n            name:        \"list_directory\",\n            description: \"List files and directories...\",\n            schema:      ListDirectorySchema,\n            handler:     newListDirectoryHandler(repoRoot),\n        },\n        // ...\n    }\n    \n    for _, tool := range tools {\n        if err := registry.RegisterTool(tool.name, tool.description, tool.schema, tool.handler); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n```\n\n## Benefits\n- Easier to test handlers (can test without registry)\n- Schemas can be validated/documented separately\n- Handler constructors can be reused\n- Clearer separation of concerns\n- Better code organization\n\n## Files to Create\n- internal/claude/schemas.go\n- internal/claude/handlers.go\n- Update internal/claude/repo_tools.go","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T09:56:00.929819-05:00","updated_at":"2025-12-15T12:56:13.95002-05:00","closed_at":"2025-12-15T12:56:13.95002-05:00","close_reason":"Refactored tool definitions and handlers into separate files. Created schemas.go with tool schemas as constants (ListDirectorySchema, ReadFileSchema, SearchFilesSchema, GetFileInfoSchema, ListGitFilesSchema). Created handlers.go with handler constructors (newListDirectoryHandler, newReadFileHandler, newSearchFilesHandler, newGetFileInfoHandler, newListGitFilesHandler). Updated repo_tools.go to use declarative tool registration with a slice of tool definitions. Removed inline schema definitions and anonymous closures. Better separation of concerns and testability. All tests passing."}
{"id":"agentctl-kd5","title":"feat(logging): integrate slog for structured logging","description":"## Based On Research\nResearch: .claude/research/20251215-go-structured-logging.md\n\n## Implementation\n\nAdd slog-based structured logging to agentctl:\n\n### 1. Create Logger Package\n```go\n// internal/logging/logger.go\npackage logging\n\nimport (\n    \"context\"\n    \"log/slog\"\n    \"os\"\n)\n\n// NewCLILogger creates a logger that routes by level:\n// Info/Debug → stdout, Warn/Error → stderr\nfunc NewCLILogger(level slog.Level) *slog.Logger {\n    return slog.New(NewLevelRouter(\n        slog.NewTextHandler(os.Stdout, \u0026slog.HandlerOptions{Level: slog.LevelInfo}),\n        slog.NewTextHandler(os.Stderr, \u0026slog.HandlerOptions{Level: slog.LevelError}),\n    ))\n}\n\n// LevelRouter routes logs to different handlers based on level\ntype LevelRouter struct {\n    stdout slog.Handler\n    stderr slog.Handler\n}\n\nfunc NewLevelRouter(stdout, stderr slog.Handler) *LevelRouter {\n    return \u0026LevelRouter{stdout: stdout, stderr: stderr}\n}\n\nfunc (r *LevelRouter) Enabled(ctx context.Context, level slog.Level) bool {\n    return true // Both handlers will filter\n}\n\nfunc (r *LevelRouter) Handle(ctx context.Context, rec slog.Record) error {\n    if rec.Level \u003e= slog.LevelWarn {\n        return r.stderr.Handle(ctx, rec)\n    }\n    return r.stdout.Handle(ctx, rec)\n}\n\nfunc (r *LevelRouter) WithAttrs(attrs []slog.Attr) slog.Handler {\n    return \u0026LevelRouter{\n        stdout: r.stdout.WithAttrs(attrs),\n        stderr: r.stderr.WithAttrs(attrs),\n    }\n}\n\nfunc (r *LevelRouter) WithGroup(name string) slog.Handler {\n    return \u0026LevelRouter{\n        stdout: r.stdout.WithGroup(name),\n        stderr: r.stderr.WithGroup(name),\n    }\n}\n```\n\n### 2. Use in Agent Execution\n```go\n// internal/agent/client.go\nfunc (a *Agent) Execute(ctx context.Context, prompt string) (string, error) {\n    logger := slog.Default()\n    \n    // ... execution code ...\n    \n    if err != nil {\n        logger.LogAttrs(ctx, slog.LevelError, \"agent execution failed\",\n            slog.String(\"program\", a.Program),\n            slog.String(\"bin_path\", a.BinPath),\n            slog.Int(\"exit_code\", exitCode),\n            slog.String(\"stderr\", stderr.String()),\n            slog.Any(\"args\", args),\n        )\n        return \"\", agentErr\n    }\n    \n    logger.Debug(\"agent execution completed\",\n        slog.String(\"program\", a.Program),\n        slog.Duration(\"duration\", elapsed),\n    )\n    \n    return output, nil\n}\n```\n\n### 3. Initialize in main.go\n```go\nfunc main() {\n    // Set default logger\n    level := slog.LevelInfo\n    if verbose {\n        level = slog.LevelDebug\n    }\n    slog.SetDefault(logging.NewCLILogger(level))\n    \n    // Execute command\n    if err := rootCmd.Execute(); err != nil {\n        // Error already logged with context via slog\n        os.Exit(exitcode.FromError(err))\n    }\n}\n```\n\n## Benefits\n- Standard library (no dependencies)\n- Structured error context for debugging\n- Proper stdout/stderr routing\n- Easy to add --json flag later for machine-readable output\n- Future-proof (slog is the Go team's answer to logging)\n\n## Files\n- Create internal/logging/logger.go\n- Update internal/agent/client.go\n- Update cmd/agentctl/main.go\n- Add --verbose/-v flag for debug logging\n\n## References\n- Go Blog: Structured Logging with slog\n- 12-Factor App: Logs convention\n- Better Stack: slog best practices","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-15T17:38:46.245935-05:00","updated_at":"2025-12-15T18:12:28.069705-05:00","closed_at":"2025-12-15T18:12:28.069705-05:00","close_reason":"Integrated slog for structured logging. Added ExecuteWithLogger and ExecuteWithSystemLogger methods that accept a logger parameter. Added structured logging for agent execution events: Info for command start and success, Warn for cancellation, Error for validation failures, timeouts, execution failures, and empty output. Log structured fields include: program, bin_path, args, exit_code, stderr, stdout, error. Maintained backward compatibility with Execute() and ExecuteWithSystem() methods. All tests passing."}
{"id":"agentctl-l11","title":"feat(agent): add --agent-cli flag to specify custom CLI binary","description":"## Feature\nAdd global flag `--agent-cli` to allow users to specify a custom CLI binary path instead of using 'claude' by default.\n\n## Use Cases\n1. Testing with different CLI versions\n2. Using alternative AI CLIs (e.g., custom wrappers)\n3. Claude CLI in non-standard location\n\n## Implementation\n\n### Add Global Flag (cmd/root.go or similar)\n```go\nvar agentCLIPath string\n\nfunc init() {\n    rootCmd.PersistentFlags().StringVar(\u0026agentCLIPath, \"agent-cli\", \"claude\", \"Path to AI agent CLI binary\")\n}\n```\n\n### Environment Variable Support\nAlso support `AGENTCTL_CLI_PATH` environment variable:\n```go\ncliPath := agentCLIPath\nif cliPath == \"claude\" {\n    if envPath := os.Getenv(\"AGENTCTL_CLI_PATH\"); envPath != \"\" {\n        cliPath = envPath\n    }\n}\n```\n\n### Pass to Agent\n```go\nagent := NewAgent()\nagent.CLIPath = cliPath\n```\n\n## Usage Examples\n```bash\n# Use custom claude binary\nagentctl --agent-cli=/usr/local/bin/claude-dev rules add \"new rule\"\n\n# Use environment variable\nexport AGENTCTL_CLI_PATH=/custom/path/claude\nagentctl rules add \"new rule\"\n\n# Use wrapper script\nagentctl --agent-cli=./scripts/claude-wrapper.sh rules init\n```\n\n## Dependencies\n- Requires agentctl-f2i (CLI conversion) to be completed first\n\n## Priority\nP2 - Nice to have, but not critical for initial CLI implementation","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-15T13:27:29.082468-05:00","updated_at":"2025-12-15T13:48:02.342515-05:00","closed_at":"2025-12-15T13:48:02.342515-05:00","close_reason":"Added global --agent-cli flag to root command. Support AGENTCTL_CLI_PATH environment variable. Updated all NewAgent() calls in add.go, init.go, and status.go to use CLI path from flag/env via GetAgentCLIPath() helper. Flag takes precedence over env var, defaults to 'claude'. All tests passing.","dependencies":[{"issue_id":"agentctl-l11","depends_on_id":"agentctl-f2i","type":"blocks","created_at":"2025-12-15T13:27:36.928799-05:00","created_by":"ryan"}]}
{"id":"agentctl-lri","title":"implement(agent): add buildArgs() with type-based argument construction","description":"## Purpose\nDifferent agent types have different CLI argument formats. Need a buildArgs() function that switches on agent Type to construct proper arguments.\n\n## Implementation\n\n```go\n// internal/agent/client.go\n\n// buildArgs constructs command arguments based on agent type\nfunc (a *Agent) buildArgs(prompt string) ([]string, error) {\n    switch a.Type {\n    case \"claude\":\n        return a.buildClaudeArgs(prompt)\n    case \"codex\":\n        return nil, fmt.Errorf(\"agent type %q not yet supported: %w\", a.Type, ErrUnsupportedAgent)\n    case \"cursor\":\n        return nil, fmt.Errorf(\"agent type %q not yet supported: %w\", a.Type, ErrUnsupportedAgent)\n    case \"aider\":\n        return nil, fmt.Errorf(\"agent type %q not yet supported: %w\", a.Type, ErrUnsupportedAgent)\n    default:\n        return nil, fmt.Errorf(\"unknown agent type %q: %w\", a.Type, ErrUnsupportedAgent)\n    }\n}\n\n// buildClaudeArgs constructs arguments for claude CLI\nfunc (a *Agent) buildClaudeArgs(prompt string) ([]string, error) {\n    if prompt == \"\" {\n        return nil, errors.New(\"prompt cannot be empty\")\n    }\n    \n    // Claude CLI format: claude --prompt \"your prompt here\"\n    return []string{\"--prompt\", prompt}, nil\n}\n\n// Placeholder for future support\nfunc (a *Agent) buildAiderArgs(prompt string) ([]string, error) {\n    // aider CLI format: aider --message \"prompt\" --yes\n    return []string{\"--message\", prompt, \"--yes\"}, nil\n}\n```\n\n## Execute Method Integration\n```go\nfunc (a *Agent) Execute(ctx context.Context, prompt string) (string, error) {\n    // Build args based on type\n    args, err := a.buildArgs(prompt)\n    if err != nil {\n        return \"\", fmt.Errorf(\"building args for %s: %w\", a.Type, err)\n    }\n\n    var stdout, stderr bytes.Buffer\n    cmd := exec.CommandContext(ctx, a.Binary, args...)\n    cmd.Stdout = \u0026stdout\n    cmd.Stderr = \u0026stderr\n\n    // ... rest of execution\n}\n```\n\n## Error Handling for Unsupported Types\n```go\n// When user tries unsupported type\nagent := NewAgent(WithType(\"cursor\"))\n_, err := agent.Execute(ctx, \"test prompt\")\n\nif errors.Is(err, agent.ErrUnsupportedAgent) {\n    fmt.Fprintf(os.Stderr, \"Agent type %q is not yet supported.\\n\", agentType)\n    fmt.Fprintf(os.Stderr, \"Supported types: claude\\n\")\n    os.Exit(exitcode.Usage)\n}\n```\n\n## Testing Strategy\n```go\nfunc TestBuildArgs(t *testing.T) {\n    tests := []struct{\n        name     string\n        agentType string\n        prompt   string\n        want     []string\n        wantErr  error\n    }{\n        {\n            name:     \"claude with valid prompt\",\n            agentType: \"claude\",\n            prompt:   \"test prompt\",\n            want:     []string{\"--prompt\", \"test prompt\"},\n        },\n        {\n            name:     \"cursor not supported\",\n            agentType: \"cursor\",\n            prompt:   \"test\",\n            wantErr:  agent.ErrUnsupportedAgent,\n        },\n        {\n            name:     \"empty prompt\",\n            agentType: \"claude\",\n            prompt:   \"\",\n            wantErr:  errors.New(\"prompt cannot be empty\"),\n        },\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            agent := NewAgent(WithType(tt.agentType))\n            args, err := agent.buildArgs(tt.prompt)\n            \n            if tt.wantErr != nil {\n                assert.Error(t, err)\n                if tt.wantErr == agent.ErrUnsupportedAgent {\n                    assert.ErrorIs(t, err, agent.ErrUnsupportedAgent)\n                }\n            } else {\n                assert.NoError(t, err)\n                assert.Equal(t, tt.want, args)\n            }\n        })\n    }\n}\n```\n\n## Future Agent Support\nWhen adding new agent types, only need to:\n1. Add case to buildArgs() switch\n2. Implement buildXXXArgs() function\n3. Add tests\n\n## Files\n- internal/agent/client.go - Add buildArgs() and type-specific builders\n- internal/agent/errors.go - Ensure ErrUnsupportedAgent exists\n- internal/agent/client_test.go - Add buildArgs tests\n\n## References\n- Research: agentctl-0pv (closed) - multi-agent patterns\n- Research: .claude/research/20251215-cli-error-patterns.md","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T18:49:00.454853-05:00","updated_at":"2025-12-16T20:45:19.751957-05:00","closed_at":"2025-12-16T20:45:19.751957-05:00","close_reason":"Closed","dependencies":[{"issue_id":"agentctl-lri","depends_on_id":"agentctl-rte","type":"blocks","created_at":"2025-12-15T18:49:07.897635-05:00","created_by":"ryan"}]}
{"id":"agentctl-m8b","title":"implement(agent): add binary validation before execution","description":"## Based On Research\nResearch: .claude/research/20251215-cli-error-patterns.md\n\n## Implementation\n\nValidate binary existence before execution:\n\n```go\n// internal/agent/client.go\n\nfunc (a *Agent) Validate() error {\n    if a.BinPath == \"\" {\n        return errors.New(\"agent binary path not set\")\n    }\n\n    if _, err := exec.LookPath(a.BinPath); err != nil {\n        return \u0026AgentError{\n            Program:  a.Program,\n            BinPath:  a.BinPath,\n            ExitCode: -1,\n            Err:      fmt.Errorf(\"%w: %v\", ErrNotFound, err),\n        }\n    }\n\n    return nil\n}\n```\n\n## Error Message\nWhen binary not found, provide actionable guidance:\n\n```go\nif errors.Is(err, agent.ErrNotFound) {\n    fmt.Fprintf(os.Stderr, `agent binary %q not found in PATH\n\nInstall options:\n  - brew install anthropics/tap/claude\n  - Or specify custom path: agentctl --agent-cli=/path/to/claude rules init\n`, binPath)\n    os.Exit(exitcode.NoInput)\n}\n```\n\n## Call Validate() Before Execute()\n```go\nfunc (c *RulesCmd) RunE(cmd *cobra.Command, args []string) error {\n    agent := NewAgent(WithProgram(\"claude\"))\n\n    // Validate first\n    if err := agent.Validate(); err != nil {\n        return err\n    }\n\n    // Then execute\n    output, err := agent.Execute(context.Background(), prompt)\n    // ...\n}\n```\n\n## Benefits\n- Fail fast with clear error before subprocess spawn\n- Better error messages (\"not found\" vs generic exec error)\n- Opportunity to suggest installation\n\n## References\n- Docker CLI binary validation\n- kubectl command not found handling\n- gh CLI path resolution","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T14:43:08.724028-05:00","updated_at":"2025-12-15T14:50:48.836516-05:00","closed_at":"2025-12-15T14:50:48.836516-05:00","close_reason":"Binary validation already implemented in Validate() method as part of agentctl-6hs. Checks if CLIPath is set and uses exec.LookPath to verify binary exists before execution."}
{"id":"agentctl-mgt","title":"implement(agent): define AgentError custom error type with exit code and stderr","description":"## Based On Research\nResearch findings from .claude/research/20251215-go-custom-error-types.md and 20251215-cli-error-patterns.md\n\n## Implementation\n\nCreate custom error type following exec.ExitError and Docker CLI StatusError patterns:\n\n```go\n// internal/agent/errors.go\npackage agent\n\nimport (\n    \"errors\"\n    \"fmt\"\n    \"strings\"\n)\n\n// AgentError wraps subprocess execution failures with rich context\ntype AgentError struct {\n    Program  string   // Agent type (\"claude\", \"aider\", etc.)\n    BinPath  string   // Actual binary path executed\n    Args     []string // Command arguments\n    ExitCode int      // Process exit code (-1 if not exit error)\n    Stdout   string   // Captured stdout\n    Stderr   string   // Captured stderr\n    Err      error    // Underlying error\n}\n\nfunc (e *AgentError) Error() string {\n    if e.Stderr != \"\" {\n        return fmt.Sprintf(\"agent %q failed (exit %d): %s\",\n            e.Program, e.ExitCode, strings.TrimSpace(e.Stderr))\n    }\n    return fmt.Sprintf(\"agent %q failed (exit %d): %v\",\n        e.Program, e.ExitCode, e.Err)\n}\n\nfunc (e *AgentError) Unwrap() error {\n    return e.Err\n}\n\n// ExitCode method for CLI frameworks\nfunc (e *AgentError) ExitCode() int {\n    if e.ExitCode \u003e 0 {\n        return e.ExitCode\n    }\n    return 1\n}\n```\n\n## Files\n- Create internal/agent/errors.go\n- Update internal/agent/client.go to return AgentError\n\n## References\n- kubectl CheckErr pattern (helpers.go)\n- Docker CLI StatusError\n- exec.ExitError from stdlib\n- fs.PathError pattern (Op/Path/Err)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T14:42:15.030058-05:00","updated_at":"2025-12-15T14:50:47.919566-05:00","closed_at":"2025-12-15T14:50:47.919566-05:00","close_reason":"AgentError custom error type already implemented in agent_error.go as part of agentctl-6hs. Includes Program, BinPath, Args, ExitCode, Stdout, Stderr, and Err fields. Implements Error() and Unwrap() methods following exec.ExitError pattern."}
{"id":"agentctl-ojd","title":"refactor: rename internal/claude to internal/agent","description":"## Scope\nRename the internal/claude package to internal/agent to better reflect its purpose as a general agent execution package (not specific to Claude SDK).\n\n## Changes Required\n1. Rename directory: internal/claude/ → internal/agent/\n2. Update package declarations in all files\n3. Update imports across codebase:\n   - internal/cli/rules/add.go\n   - internal/cli/rules/init.go\n   - Any test files\n\n## Files to Rename\n- internal/claude/client.go → internal/agent/client.go\n- internal/claude/tools.go → internal/agent/tools.go\n- internal/claude/repo_tools.go → internal/agent/repo_tools.go\n- internal/claude/errors.go → internal/agent/errors.go\n- All test files\n\n## Note\nThis should be done BEFORE converting from SDK to CLI, as it's a simple rename that will reduce merge conflicts.\n\n## Blocks\n- agentctl-4lr (CLI conversion)\n- Any other SDK-related refactoring","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T13:27:04.37514-05:00","updated_at":"2025-12-15T13:43:36.486218-05:00","closed_at":"2025-12-15T13:43:36.486218-05:00","close_reason":"Renamed internal/claude package to internal/agent. Renamed directory, updated all package declarations from 'package anthropic' to 'package agent', updated all imports from 'internal/claude' to 'internal/agent', and updated import aliases from 'anthclient' to 'agentclient' across all files (add.go, init.go, status.go, and all test files). All tests passing."}
{"id":"agentctl-p9a","title":"feat(rules): add input validation for add command","description":"## Problem\nThe `rules add` command lacks proper input validation for user-provided values.\n\n## Missing Validations\n\n### 1. Rule name sanitization (line 69 in add.go)\n```go\nfilename = sanitizeSkillName(strings.Join(words[:maxWords], \"-\"))\n```\n**Issues**:\n- No validation of sanitized result (could be empty after sanitization)\n- No check for name conflicts with existing skills\n- No validation of length limits\n\n### 2. Description validation\n- `--description` flag accepts any string (line 108)\n- No length limits\n- No check for empty/whitespace-only descriptions\n\n### 3. When-to-use validation\n- `--when-to-use` flag accepts any string (line 109)\n- No guidance on format\n\n### 4. Applies-to validation\n- `--applies-to` accepts arbitrary values (line 110)\n- Should validate against known tools: \"claude\", \"cursor\", \"windsurf\"\n- Or at least warn about unknown tools\n\n### 5. Prompt validation\n- No minimum length check for prompt argument\n- No check for obviously invalid prompts (e.g., single character)\n\n## Proposed Validations\n\n### Name validation\n```go\nfunc validateRuleName(name string) error {\n    if name == \"\" {\n        return fmt.Errorf(\"rule name cannot be empty\")\n    }\n    if len(name) \u003e 50 {\n        return fmt.Errorf(\"rule name too long (max 50 characters)\")\n    }\n    if !regexp.MustCompile(\"^[a-z0-9-]+$\").MatchString(name) {\n        return fmt.Errorf(\"rule name can only contain lowercase letters, numbers, and hyphens\")\n    }\n    return nil\n}\n```\n\n### Applies-to validation\n```go\nvar knownTools = []string{\"claude\", \"cursor\", \"windsurf\", \"aider\"}\n\nfunc validateAppliesTo(tools []string) error {\n    for _, tool := range tools {\n        if !contains(knownTools, tool) {\n            fmt.Printf(\"⚠ Warning: unknown tool '%s' (known: %s)\\n\", \n                tool, strings.Join(knownTools, \", \"))\n        }\n    }\n    return nil\n}\n```\n\n### Prompt validation\n```go\nfunc validatePrompt(prompt string) error {\n    prompt = strings.TrimSpace(prompt)\n    if len(prompt) \u003c 10 {\n        return fmt.Errorf(\"prompt too short (minimum 10 characters)\")\n    }\n    if len(prompt) \u003e 1000 {\n        return fmt.Errorf(\"prompt too long (maximum 1000 characters)\")\n    }\n    return nil\n}\n```\n\n## Benefits\n- Catch errors early (before API call)\n- Save API credits on invalid inputs\n- Better user experience with clear validation errors\n- Prevent edge cases from reaching SDK\n\n## Files\n- internal/cli/rules/add.go (lines 34-104)","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-15T09:56:34.865539-05:00","updated_at":"2025-12-15T12:52:50.566729-05:00","closed_at":"2025-12-15T12:52:50.566729-05:00","close_reason":"Added comprehensive input validation for rules add command. Implemented validatePrompt (min 10 chars, max 1000 chars), validateRuleName (non-empty, max 50 chars, lowercase alphanumeric + hyphens), validateDescription (non-empty, max 200 chars), validateWhenToUse (non-empty, max 300 chars), validateAppliesTo (warn on unknown tools, validate known tools), and checkNameConflict (check for existing rule name conflicts). All validations run before API call to save credits. Better error messages with fix suggestions. All tests passing."}
{"id":"agentctl-pb9","title":"implement(errors): define sysexits.h exit code constants","description":"## Based On Research\nResearch: .claude/research/20251215-go-error-messages.md, 20251215-cli-error-patterns.md\n\n## Implementation\n\nCreate exit code constants following sysexits.h convention:\n\n```go\n// internal/exitcode/exitcode.go\npackage exitcode\n\nconst (\\n    // Success\n    OK = 0\n\n    // sysexits.h codes (64-78)\n    Usage       = 64 // Bad command line usage\n    DataErr     = 65 // Input data format error\n    NoInput     = 66 // Cannot open input file\n    Unavailable = 69 // Service unavailable\n    Software    = 70 // Internal software error (bug)\n    OSErr       = 71 // System error\n    IOErr       = 74 // Input/output error\n    TempFail    = 75 // Temporary failure (retry may help)\n    NoPerm      = 77 // Permission denied\n    Config      = 78 // Configuration error\n\n    // Signal conventions\n    // 128+N = signal N (e.g., 130 = Ctrl+C/SIGINT)\n\n    // Default\n    DefaultErr = 1 // Generic error\n)\n\n// FromError extracts exit code from error\nfunc FromError(err error) int {\n    if err == nil {\n        return OK\n    }\n\n    // Check for AgentError with exit code\n    var agentErr *agent.AgentError\n    if errors.As(err, \u0026agentErr) {\n        if agentErr.ExitCode \u003e 0 {\n            return agentErr.ExitCode\n        }\n    }\n\n    // Check for exec.ExitError\n    var exitErr *exec.ExitError\n    if errors.As(err, \u0026exitErr) {\n        return exitErr.ExitCode()\n    }\n\n    return DefaultErr\n}\n```\n\n## Usage in main.go\n```go\nfunc main() {\n    if err := rootCmd.Execute(); err != nil {\n        fmt.Fprintf(os.Stderr, \"Error: %v\\n\", err)\n        os.Exit(exitcode.FromError(err))\n    }\n}\n```\n\n## Files\n- Create internal/exitcode/exitcode.go\n- Update cmd/agentctl/main.go to use exitcode.FromError()\n\n## References\n- sysexits.h man page\n- square/exit package\n- kubectl helpers.go CheckErr\n- Docker CLI exit code mapping","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-15T14:43:08.090543-05:00","updated_at":"2025-12-15T14:55:05.679592-05:00","closed_at":"2025-12-15T14:55:05.679592-05:00","close_reason":"Defined sysexits.h exit code constants in internal/errors/exitcode.go. Follows sysexits.h conventions (64-78) plus ExitOK (0) for successful completion. Provides constants for common error scenarios: ExitUsage, ExitDataErr, ExitNoInput, ExitNoUser, ExitNoHost, ExitUnavailable, ExitSoftware, ExitOSErr, ExitOSFile, ExitCantCreat, ExitIOErr, ExitTempFail, ExitProtocol, ExitNoPerm, ExitConfig. All tests passing."}
{"id":"agentctl-q61","title":"feat(cli): add --agent-binary global flag to specify custom binary path","description":"## Purpose\nAllow users to specify custom binary path via CLI flag, overriding the default Type-based binary name.\n\n## Implementation\n\n### 1. Add Global Flag\n```go\n// cmd/agentctl/root.go or similar\nvar (\n    agentType   string\n    agentBinary string\n)\n\nfunc init() {\n    rootCmd.PersistentFlags().StringVar(\u0026agentType, \"agent-type\", \"claude\",\n        \"Agent type to use (claude, aider, etc.)\")\n    rootCmd.PersistentFlags().StringVar(\u0026agentBinary, \"agent-binary\", \"\",\n        \"Path to agent binary (defaults to agent type)\")\n}\n```\n\n### 2. Create Agent from Flags\n```go\n// Helper function to create agent from global flags\nfunc newAgentFromFlags() *agent.Agent {\n    opts := []agent.Option{\n        agent.WithType(agentType),\n    }\n    \n    // Only set custom binary if flag provided\n    if agentBinary != \"\" {\n        opts = append(opts, agent.WithBinary(agentBinary))\n    }\n    // Otherwise Binary defaults to Type value\n    \n    return agent.NewAgent(opts...)\n}\n```\n\n### 3. Usage in Commands\n```go\n// internal/cli/rules/add.go\nfunc (c *AddCmd) RunE(cmd *cobra.Command, args []string) error {\n    agent := newAgentFromFlags()\n    \n    output, err := agent.Execute(context.Background(), prompt)\n    // ...\n}\n```\n\n## Usage Examples\n\n**Default (claude):**\n```bash\nagentctl rules add \"create rule\"\n# Uses: Type=\"claude\", Binary=\"claude\"\n```\n\n**Custom binary path:**\n```bash\nagentctl --agent-binary=/usr/local/bin/claude rules add \"create rule\"\n# Uses: Type=\"claude\", Binary=\"/usr/local/bin/claude\"\n```\n\n**Different agent type:**\n```bash\nagentctl --agent-type=aider rules add \"create rule\"\n# Uses: Type=\"aider\", Binary=\"aider\"\n# (when aider support is implemented)\n```\n\n**Both custom type and binary:**\n```bash\nagentctl --agent-type=claude --agent-binary=./bin/claude-dev rules add \"create rule\"\n# Uses: Type=\"claude\", Binary=\"./bin/claude-dev\"\n```\n\n## Environment Variable Support\nAlso support environment variables:\n```go\nfunc init() {\n    rootCmd.PersistentFlags().StringVar(\u0026agentType, \"agent-type\",\n        getEnvOrDefault(\"AGENTCTL_AGENT_TYPE\", \"claude\"),\n        \"Agent type to use\")\n    rootCmd.PersistentFlags().StringVar(\u0026agentBinary, \"agent-binary\",\n        os.Getenv(\"AGENTCTL_AGENT_BINARY\"),\n        \"Path to agent binary\")\n}\n```\n\n**Usage:**\n```bash\nexport AGENTCTL_AGENT_BINARY=/custom/path/claude\nagentctl rules add \"create rule\"\n```\n\n## Error Handling\n```go\n// Validate binary exists if custom path provided\nif agentBinary != \"\" {\n    if _, err := exec.LookPath(agentBinary); err != nil {\n        return fmt.Errorf(\"agent binary not found: %s\\n\\nCheck the path or remove --agent-binary flag to use default\", agentBinary)\n    }\n}\n```\n\n## Help Documentation\n```\nGlobal Flags:\n  --agent-type string     Agent type to use (default \"claude\")\n  --agent-binary string   Path to agent binary (defaults to agent type)\n\nEnvironment Variables:\n  AGENTCTL_AGENT_TYPE     Default agent type\n  AGENTCTL_AGENT_BINARY   Path to agent binary\n\nExamples:\n  # Use claude from PATH\n  agentctl rules add \"new rule\"\n\n  # Use custom binary location\n  agentctl --agent-binary=/usr/local/bin/claude-dev rules add \"new rule\"\n\n  # Use environment variable\n  export AGENTCTL_AGENT_BINARY=/custom/claude\n  agentctl rules add \"new rule\"\n```\n\n## Files\n- cmd/agentctl/root.go - Add global flags\n- internal/cli/rules/add.go - Use newAgentFromFlags()\n- internal/cli/rules/init.go - Use newAgentFromFlags()\n\n## Dependencies\n- Requires agent struct refactor (Type/Binary fields)\n\n## References\n- Research: agentctl-l11 (similar feature)\n- kubectl --kubeconfig pattern\n- docker --host pattern","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-15T18:49:00.756878-05:00","updated_at":"2025-12-16T20:51:51.162511-05:00","closed_at":"2025-12-16T20:51:51.162511-05:00","close_reason":"Closed","dependencies":[{"issue_id":"agentctl-q61","depends_on_id":"agentctl-rte","type":"blocks","created_at":"2025-12-15T18:49:08.210947-05:00","created_by":"ryan"}]}
{"id":"agentctl-rte","title":"refactor(agent): rename Agent struct fields to Type and Binary with proper defaults","description":"## Problem\nCurrent Agent struct uses Program/BinPath which is confusing. Need clearer naming:\n- Type: identifies agent type (\"claude\", \"codex\", \"cursor\")\n- Binary: path to binary (defaults to Type value)\n\n## Current Implementation\n```go\ntype Agent struct {\n    Program  string   // Confusing name\n    BinPath  string   // Confusing name\n    Args     []string\n    // ...\n}\n```\n\n## Required Implementation\n```go\n// internal/agent/client.go\ntype Agent struct {\n    Type   string        // Agent type: \"claude\", \"codex\", \"cursor\", etc.\n    Binary string        // Path to binary (defaults to Type)\n    Timeout time.Duration // Execution timeout (default: 5 minutes)\n}\n\n// NewAgent creates an agent with defaults\nfunc NewAgent(opts ...Option) *Agent {\n    agent := \u0026Agent{\n        Type:    \"claude\",\n        Binary:  \"claude\",\n        Timeout: 5 * time.Minute,\n    }\n    for _, opt := range opts {\n        opt(agent)\n    }\n    return agent\n}\n\n// Option pattern for configuration\ntype Option func(*Agent)\n\nfunc WithType(agentType string) Option {\n    return func(a *Agent) {\n        a.Type = agentType\n        // Auto-update Binary if it matches old Type\n        if a.Binary == \"\" || a.Binary == \"claude\" {\n            a.Binary = agentType\n        }\n    }\n}\n\nfunc WithBinary(path string) Option {\n    return func(a *Agent) {\n        a.Binary = path\n    }\n}\n\nfunc WithTimeout(timeout time.Duration) Option {\n    return func(a *Agent) {\n        a.Timeout = timeout\n    }\n}\n```\n\n## Usage Examples\n```go\n// Default: claude agent\nagent := NewAgent()\n// agent.Type = \"claude\", agent.Binary = \"claude\"\n\n// Custom type\nagent := NewAgent(WithType(\"aider\"))\n// agent.Type = \"aider\", agent.Binary = \"aider\"\n\n// Custom binary path\nagent := NewAgent(WithBinary(\"/usr/local/bin/claude\"))\n// agent.Type = \"claude\", agent.Binary = \"/usr/local/bin/claude\"\n\n// Both\nagent := NewAgent(\n    WithType(\"claude\"),\n    WithBinary(\"/custom/path/claude-dev\"),\n)\n```\n\n## Update AgentError\n```go\ntype AgentError struct {\n    Type     string   // Changed from Program\n    Binary   string   // Changed from BinPath\n    Args     []string\n    ExitCode int\n    Stdout   string\n    Stderr   string\n    Err      error\n}\n\nfunc (e *AgentError) Error() string {\n    if e.Stderr != \"\" {\n        return fmt.Sprintf(\"agent %q failed (exit %d): %s\",\n            e.Type, e.ExitCode, strings.TrimSpace(e.Stderr))\n    }\n    return fmt.Sprintf(\"agent %q failed (exit %d)\", e.Type, e.ExitCode)\n}\n```\n\n## Files to Update\n- internal/agent/client.go - Agent struct definition\n- internal/agent/agent_error.go - AgentError struct\n- internal/cli/rules/add.go - Update NewAgent() calls\n- internal/cli/rules/init.go - Update NewAgent() calls\n\n## Benefits\n- Clearer naming (Type vs Program)\n- Binary defaults to Type (DRY principle)\n- Easy to specify custom paths\n- Functional options pattern (idiomatic Go)\n\n## References\n- Functional options pattern (Dave Cheney)\n- Research: .claude/research/20251215-cli-error-patterns.md","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-15T18:49:00.135878-05:00","updated_at":"2025-12-16T20:42:21.139563-05:00","closed_at":"2025-12-16T20:42:21.139563-05:00","close_reason":"Closed"}
